package main

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"encoding/gob"
	"encoding/hex"
	"fmt"
	"math/big"
	"os"
	"strings"
)

// reward
const subsidy = 10

// TXInput struct has the ID of previous transaction
type TXInput struct {
	TXid   []byte
	Vout   int
	Sign   []byte
	PubKey []byte
}

// TXOutput the output(coins) of a TX
type TXOutput struct {
	Value      int
	PubKeyHash []byte
}

// Transaction for storing txid, tx input and output
type Transaction struct {
	TXid []byte
	Vin  []TXInput
	Vout []TXOutput
}

// SetID sets the TXID based on hash of its contents
func (tx *Transaction) SetID() {
	var encoded bytes.Buffer
	var hash [32]byte
	encoder := gob.NewEncoder(&encoded)
	encoder.Encode(tx)
	hash = sha256.Sum256(encoded.Bytes())
	tx.TXid = hash[:]
}

// NewCoionbaseTX creates a coinbase tx and returns it
// it can only be generated by a *miner*
func NewCoionbaseTX(to string, data string) *Transaction {
	// pubKeyHash := Base58Decode(to)
	// pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4]
	if data == "" {
		data = "reward to " + string(to)
	}
	txin := TXInput{[]byte{}, -1, nil, []byte(data)}
	txout := NewTXOutput(subsidy, to)
	tx := Transaction{nil, []TXInput{txin}, []TXOutput{*txout}}
	tx.SetID()
	return &tx
}

// CanUnlockOutputWith check
// func (in *TXInput) CanUnlockOutputWith(unlockData string) bool {
// 	if in.Sign == unlockData {
// 		return true
// 	}
// 	return false
// }

// String fmt
func (tx Transaction) String() string {
	var lines []string

	lines = append(lines, fmt.Sprintf("--- Transaction %x:", tx.TXid))

	for i, input := range tx.Vin {

		lines = append(lines, fmt.Sprintf("     Input %d:", i))
		lines = append(lines, fmt.Sprintf("       TXID:      %x", input.TXid))
		lines = append(lines, fmt.Sprintf("       Out:       %d", input.Vout))
		lines = append(lines, fmt.Sprintf("       Signature: %x", input.Sign))
		lines = append(lines, fmt.Sprintf("       PubKey:    %x", input.PubKey))
	}

	for i, output := range tx.Vout {
		lines = append(lines, fmt.Sprintf("     Output %d:", i))
		lines = append(lines, fmt.Sprintf("       Value:  %d", output.Value))
		lines = append(lines, fmt.Sprintf("       Script: %x", output.PubKeyHash))
	}

	return strings.Join(lines, "\n")
}

// UsesKey func
func (in *TXInput) UsesKey(publickeyhash []byte) bool {
	inpHash := HashPubKey(in.PubKey)
	if bytes.Compare(inpHash, publickeyhash) == 0 {
		return true
	}
	return false
}

// CanbeUnlockedWith check
// func (out *TXOutput) CanbeUnlockedWith(unlockData string) bool {
// 	if out.PubKeyHash == unlockData {
// 		return true
// 	}
// 	return false
// }

// Lock func
func (out *TXOutput) Lock(address []byte) {
	pubkeyhash := Base58Decode(address)
	pubkeyhash = pubkeyhash[1 : len(pubkeyhash)-4]
	out.PubKeyHash = pubkeyhash
	return
}

// IsLockedWith func
func (out *TXOutput) IsLockedWith(pubkeyhash []byte) bool {
	temp := bytes.Compare(out.PubKeyHash, pubkeyhash)
	if temp == 0 {
		return true
	}
	return false
}

// IsCoinBaseTX check if TX is coinbase
func (tx Transaction) IsCoinBaseTX() bool {
	if len(tx.Vin) == 1 && len(tx.Vin[0].TXid) == 0 && tx.Vin[0].Vout == -1 {
		return true
	}
	return false
}

// NewTXOutput create a new TXOutput
func NewTXOutput(value int, address string) *TXOutput {
	txo := &TXOutput{value, nil}
	txo.Lock([]byte(address))
	return txo
}

// NewUTXOTransaction creates a new tx from one peer to another
func NewUTXOTransaction(from, to string, amount int, bc *BlockChain) *Transaction {
	var inputs []TXInput
	var outputs []TXOutput
	wallets := NewWallets()

	wallet := wallets.GetWallet(string(from))
	pubkeyhash := HashPubKey(wallet.PublicKey)

	accumulated, spendableOutputs := bc.FindSpendableOutputs(pubkeyhash, amount)
	if accumulated < amount {
		fmt.Println("Not enough coins for address: ", from, "coins: ", accumulated)
		os.Exit(2)
	}
	for txid, out := range spendableOutputs {
		TXid, _ := hex.DecodeString(txid)
		for _, out := range out {
			input := TXInput{TXid, out, nil, wallet.PublicKey}
			inputs = append(inputs, input)
		}
	}
	outputs = append(outputs, *NewTXOutput(amount, to))
	if accumulated > amount {
		outputs = append(outputs, *NewTXOutput(accumulated-amount, from))
	}

	tx := Transaction{nil, inputs, outputs}
	tx.TXid = tx.Hash()
	bc.SignTX(&tx, wallet.PrivateKey)

	return &tx
}

// Implementing signatures
// 1. Public key hashes stored in unlocked outputs. This identifies “sender” of a transaction.
// 2. Public key hashes stored in new, locked, outputs. This identifies “recipient” of a transaction.
// 3. Values of new outputs.

// TrimTransaction returns compressed fmt of TX
func (tx *Transaction) TrimTransaction() Transaction {
	var inp []TXInput
	var out []TXOutput
	for _, vin := range tx.Vin {
		inp = append(inp, TXInput{vin.TXid, vin.Vout, nil, nil})
	}
	for _, vout := range tx.Vout {
		out = append(out, TXOutput{vout.Value, vout.PubKeyHash})
	}
	txtrim := Transaction{tx.TXid, inp, out}
	return txtrim
}

// Serialise Set ID and serialize func
func (tx Transaction) Serialise() []byte {
	var enc bytes.Buffer
	var hash [32]byte
	encoder := gob.NewEncoder(&enc)
	encoder.Encode(tx)
	hash = sha256.Sum256(enc.Bytes())
	tx.TXid = hash[:]
	return enc.Bytes()
}

// Hash of the TX
func (tx *Transaction) Hash() []byte {
	var hash [32]byte
	txCopy := *tx
	txCopy.TXid = []byte{}
	hash = sha256.Sum256(txCopy.Serialise())

	return hash[:]
}

// Sign the TX
func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {
	if tx.IsCoinBaseTX() {
		return
	}
	txCopy := tx.TrimTransaction()
	for inID, vin := range txCopy.Vin {
		prevTx := prevTXs[hex.EncodeToString(vin.TXid)]
		txCopy.Vin[inID].Sign = nil
		txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash
		txCopy.TXid = txCopy.Hash()
		txCopy.Vin[inID].PubKey = nil
		r, s, _ := ecdsa.Sign(rand.Reader, &privKey, txCopy.TXid)
		signature := append(r.Bytes(), s.Bytes()...)
		tx.Vin[inID].Sign = signature
	}
}

// Verify func
func (tx *Transaction) Verify(PrevTX map[string]Transaction) bool {
	txtrim := tx.TrimTransaction()
	ellipticCurve := elliptic.P256()
	for inid, vin := range tx.Vin {
		prevTX := PrevTX[hex.EncodeToString(vin.TXid)]
		txtrim.Vin[inid].Sign = nil
		txtrim.Vin[inid].PubKey = prevTX.Vout[vin.Vout].PubKeyHash
		txtrim.TXid = txtrim.Hash()
		txtrim.Vin[inid].PubKey = nil
		r := big.Int{}
		s := big.Int{}
		signLen := len(vin.Sign)
		r.SetBytes(vin.Sign[:(signLen / 2)])
		s.SetBytes(vin.Sign[(signLen / 2):])

		x := big.Int{}
		y := big.Int{}
		keylen := len(vin.PubKey)
		x.SetBytes(vin.PubKey[:(keylen / 2)])
		y.SetBytes(vin.PubKey[(keylen / 2):])

		pubkeytest := ecdsa.PublicKey{ellipticCurve, &x, &y}
		fmt.Println("verify", tx.TXid, txtrim.TXid)
		fmt.Println(ecdsa.Verify(&pubkeytest, txtrim.TXid, &r, &s))
		if !ecdsa.Verify(&pubkeytest, txtrim.TXid, &r, &s) {
			return false
		}
	}
	return true
}
